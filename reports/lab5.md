1.具体代码在os/proc.c 448
可以看到需要回收的资源有：当前线程（线程的中断帧，context， 用户栈）当该进程的所有线程的资源都释放之后，释放进程资源（其他线程资源，页表，打开的文件）更新状态
需要回收，检测一下线程state，如果还在运行中的，强制回收，如果还是UNUSED状态的，就跳过
2.主要区别是对m->locked 标志位处理的时机不同，第一个设计可能会造成死锁。

实验思路：
总体来说，了解了锁和信号量的大体运作机制，仔细阅读并理解文档描述，按照步骤依次实现起来不算困难
踩坑点：信号量P操作和更新死锁检测数组的顺序需要先P操作后更新，要不然造成资源数组的更新不及时，被切到别的线程再检测死锁会出现问题。
还有一个吐槽的点：文档上说available数组的每个元素代表可利用某一类资源的数目，感觉不是很确切，我感觉用单个资源的更新状态范围更确切一些，因为文档已经暗示要把两种（互斥锁和信号量）要分开检测了，反正我是对着TA的建议实现的deadlock_detect理解了好久。
